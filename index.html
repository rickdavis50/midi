<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MIDI Pads MVP</title>
<style>
  :root {
    --bg: #05060a;
    --panel: #0b1020;
    --pad: #0a0f1d;
    --pad2: #0d1530;
    --ink: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.62);
    --c1: #00e5ff;
    --c2: #ff2dff;
    --c3: #7CFF4E;
    --c4: #ffd24a;
    --border: rgba(255,255,255,.08);
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: radial-gradient(circle at 20% 20%, rgba(0,229,255,0.08), transparent 40%),
                radial-gradient(circle at 80% 30%, rgba(255,45,255,0.06), transparent 45%),
                radial-gradient(circle at 50% 80%, rgba(124,255,78,0.05), transparent 45%),
                #05060a;
    color: var(--ink);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    overflow: hidden;
  }
  body::before {
    content: "";
    position: fixed;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 70%);
  }
  .app {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    padding: 16px;
  }
  .top-bar {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    color: var(--ink);
    border: 1px solid rgba(255,255,255,0.15);
    padding: 8px 14px;
    border-radius: 999px;
    cursor: pointer;
    font-size: 12px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
  }
  button:hover {
    border-color: rgba(0,229,255,0.6);
    box-shadow: 0 0 14px rgba(0,229,255,0.35);
  }
  button:active {
    transform: translateY(1px);
  }
  #panicBtn {
    border-color: rgba(255,210,74,0.35);
    box-shadow: 0 0 10px rgba(255,45,255,0.25);
  }
  #panicBtn:hover {
    box-shadow: 0 0 16px rgba(255,45,255,0.45);
  }
  .layout {
    display: grid;
    grid-template-columns: 1fr 320px;
    gap: 16px;
    align-items: center;
    width: min(940px, 96vw);
  }
  .app .pad-surface {
    position: relative;
    width: clamp(320px, 70vh, 620px);
    aspect-ratio: 1 / 1;
    border-radius: 22px;
    padding: clamp(18px, 3vw, 26px);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: clamp(12px, 2vw, 18px);
    touch-action: none;
    border: 1px solid rgba(255,255,255,0.08);
    background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(0,0,0,0.35));
    box-shadow: 0 20px 60px rgba(0,0,0,0.55);
    overflow: hidden;
  }
  .app .pad-surface::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 20px;
    background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(0,0,0,0.2));
    pointer-events: none;
  }
  @supports (backdrop-filter: blur(6px)) {
    .app .pad-surface {
      backdrop-filter: blur(6px);
    }
  }
  .app .pad {
    position: relative;
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)),
                linear-gradient(180deg, #0b1224, #070b16);
    border: 1px solid rgba(0,0,0,0.6);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-size: clamp(16px, 2vw, 22px);
    color: rgba(255,255,255,0.85);
    user-select: none;
    box-shadow:
      inset 0 2px 2px rgba(255,255,255,0.08),
      inset 0 -10px 14px rgba(0,0,0,0.65),
      0 8px 14px rgba(0,0,0,0.5);
    transition: transform 0.1s ease, box-shadow 0.1s ease, color 0.1s ease;
    overflow: hidden;
  }
  .app .pad::before {
    content: "";
    position: absolute;
    inset: 10px;
    border-radius: 12px;
    background: linear-gradient(145deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
    box-shadow: inset 0 1px 2px rgba(255,255,255,0.2),
                inset 0 -6px 10px rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .app .pad::after {
    content: "";
    position: absolute;
    inset: -20%;
    border-radius: 50%;
    background: radial-gradient(circle, var(--led, #00e5ff) 0%, transparent 55%);
    opacity: 0.55;
    filter: blur(6px);
    pointer-events: none;
  }
  .app .pad:hover::after {
    opacity: 0.75;
  }
  .app .pad.active {
    transform: translateY(3px) scale(0.99);
    box-shadow:
      inset 0 1px 1px rgba(255,255,255,0.1),
      inset 0 -6px 10px rgba(0,0,0,0.6),
      0 0 18px var(--led, #00e5ff),
      0 0 30px rgba(0,0,0,0.55);
  }
  .app .pad-number {
    font-weight: 600;
    text-shadow: 0 0 6px rgba(0,0,0,0.6);
  }
  .app .pad-label {
    font-size: 11px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--muted);
  }
  .app .diagnostics {
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.12);
    border-top: 2px solid rgba(0,229,255,0.5);
    border-radius: 14px;
    padding: 12px;
    height: min(70vh, 70vw, 520px);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    gap: 8px;
    font-size: 12px;
  }
  .diagnostics pre {
    flex: 1;
    margin: 0;
    background: linear-gradient(transparent 50%, rgba(255,255,255,0.03) 50%),
                repeating-linear-gradient(0deg, rgba(0,0,0,0.2), rgba(0,0,0,0.2) 2px, transparent 2px, transparent 4px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    padding: 8px;
    color: var(--ink);
    overflow: auto;
    font-family: "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .status {
    color: var(--muted);
    font-size: 12px;
  }
  @media (prefers-reduced-motion: reduce) {
    .app .pad::before { transition: none; }
    .app .pad::after { transition: none; }
  }
  .app .pad:focus-visible {
    outline: 2px solid rgba(255,255,255,0.6);
    outline-offset: 3px;
  }
  .app .pad:nth-child(8n+1) { --led: #ff4d4d; }
  .app .pad:nth-child(8n+2) { --led: #ff7a1a; }
  .app .pad:nth-child(8n+3) { --led: #ffd24a; }
  .app .pad:nth-child(8n+4) { --led: #7CFF4E; }
  .app .pad:nth-child(8n+5) { --led: #00e5ff; }
  .app .pad:nth-child(8n+6) { --led: #4d7dff; }
  .app .pad:nth-child(8n+7) { --led: #8a5cff; }
  .app .pad:nth-child(8n) { --led: #ff2dff; }
  @media (max-width: 860px) {
    .layout {
      grid-template-columns: 1fr;
      justify-items: center;
    }
    .diagnostics {
      width: min(90vw, 520px);
      height: 220px;
    }
  }
</style>
</head>
<body>
  <div class="app">
    <div class="top-bar">
      <button id="unlockBtn">Unlock Audio</button>
      <button id="testBtn">Test: play 4 notes</button>
      <button id="panicBtn">Panic / Stop</button>
    </div>
    <div class="layout">
      <div id="padSurface" class="pad-surface" aria-label="Pad grid"></div>
      <div class="diagnostics">
        <div class="status" id="audioStatus">Audio: locked</div>
        <div class="status" id="eventStatus">Events: idle</div>
        <pre id="diagOutput"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  const padSurface = document.getElementById("padSurface");
  const diagOutput = document.getElementById("diagOutput");
  const audioStatus = document.getElementById("audioStatus");
  const eventStatus = document.getElementById("eventStatus");
  const unlockBtn = document.getElementById("unlockBtn");
  const testBtn = document.getElementById("testBtn");
  const panicBtn = document.getElementById("panicBtn");

  const pads = [];
  const activePadCounts = new Map();
  const pointerContacts = new Map();
  const touchContacts = new Map();
  const activeVoices = new Set();

  let audioCtx = null;
  let masterGain = null;

  const chordMap = ["C", "G", "Am", "F"];
  const chordColors = ["var(--c1)", "var(--c2)", "var(--c3)", "var(--c4)"];
  const chords = {
    C: [261.63, 329.63, 392.0, 523.25],
    G: [196.0, 246.94, 293.66, 392.0],
    Am: [220.0, 261.63, 329.63, 440.0],
    F: [174.61, 220.0, 261.63, 349.23]
  };
  const scaleNotes = [
    261.63, 311.13, 349.23, 392.0,
    466.16, 523.25, 622.25, 698.46,
    783.99, 932.33, 1046.5, 1244.5
  ];

  function ensureAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }
    audioStatus.textContent = `Audio: ${audioCtx.state}`;
  }

  function startSustainOsc(frequency, gainValue, when = audioCtx.currentTime) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sawtooth";
    osc.frequency.value = frequency;
    osc.connect(gain);
    gain.connect(masterGain);

    gain.gain.setValueAtTime(0.0001, when);
    gain.gain.linearRampToValueAtTime(gainValue, when + 0.01);
    osc.start(when);

    return { osc, gain };
  }

  function startVoiceForPad(padIndex) {
    const when = audioCtx ? audioCtx.currentTime : 0;
    if (padIndex < 4) {
      const chord = chords[chordMap[padIndex]] || [];
      const voices = chord.map(note => startSustainOsc(note, 0.12, when));
      const voice = {
        voices,
        stop(release = 0.14) {
          const now = audioCtx.currentTime;
          voices.forEach(({ osc, gain }) => {
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(Math.max(gain.gain.value, 0.0001), now);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + release);
            osc.stop(now + release + 0.03);
          });
        }
      };
      activeVoices.add(voice);
      return voice;
    }
    const scaleIndex = (padIndex - 4) % scaleNotes.length;
    const { osc, gain } = startSustainOsc(scaleNotes[scaleIndex], 0.2, when);
    const voice = {
      osc,
      gain,
      stop(release = 0.14) {
        const now = audioCtx.currentTime;
        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(Math.max(gain.gain.value, 0.0001), now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + release);
        osc.stop(now + release + 0.03);
      }
    };
    activeVoices.add(voice);
    osc.onended = () => activeVoices.delete(voice);
    return voice;
  }

  function releaseVoice(voice, release = 0.14) {
    if (!voice) return;
    voice.stop(release);
    activeVoices.delete(voice);
  }

  function incrementPad(index) {
    const count = (activePadCounts.get(index) || 0) + 1;
    activePadCounts.set(index, count);
    pads[index].classList.toggle("active", count > 0);
  }

  function decrementPad(index) {
    if (index == null || index < 0) return;
    const count = (activePadCounts.get(index) || 0) - 1;
    if (count <= 0) {
      activePadCounts.delete(index);
      pads[index].classList.remove("active");
    } else {
      activePadCounts.set(index, count);
    }
  }

  function triggerPad(index) {
    if (index == null || index < 0) return null;
    const voice = startVoiceForPad(index);
    incrementPad(index);
    return voice;
  }

  function releaseContact(contact) {
    if (!contact) return;
    if (contact.voice) {
      releaseVoice(contact.voice);
      contact.voice = null;
    }
    if (contact.padIndex != null && contact.padIndex >= 0) {
      decrementPad(contact.padIndex);
      contact.padIndex = -1;
    }
  }

  function stopAllVoices() {
    for (const voice of Array.from(activeVoices)) {
      voice.stop(0.02);
    }
    activeVoices.clear();
  }

  function panic() {
    stopAllVoices();
    pointerContacts.clear();
    touchContacts.clear();
    activePadCounts.clear();
    pads.forEach(p => p.classList.remove("active"));
    eventStatus.textContent = "Events: cleared";
  }

  function getPadIndexFromClientXY(x, y) {
    const rect = padSurface.getBoundingClientRect();
    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
      return -1;
    }
    const relX = (x - rect.left) / rect.width;
    const relY = (y - rect.top) / rect.height;
    const col = Math.min(3, Math.max(0, Math.floor(relX * 4)));
    const row = Math.min(3, Math.max(0, Math.floor(relY * 4)));
    return row * 4 + col;
  }

  function handlePointerDown(e) {
    ensureAudio();
    const padIndex = getPadIndexFromClientXY(e.clientX, e.clientY);
    const voice = triggerPad(padIndex);
    pointerContacts.set(e.pointerId, {
      padIndex,
      voice,
      x: e.clientX,
      y: e.clientY
    });
    padSurface.setPointerCapture(e.pointerId);
    eventStatus.textContent = `Pointer: down (id ${e.pointerId})`;
  }

  function handlePointerMove(e) {
    if (!pointerContacts.has(e.pointerId)) return;
    const contact = pointerContacts.get(e.pointerId);
    const newPad = getPadIndexFromClientXY(e.clientX, e.clientY);
    if (newPad !== contact.padIndex) {
      releaseContact(contact);
      if (newPad >= 0) {
        contact.voice = triggerPad(newPad);
        contact.padIndex = newPad;
      }
    }
    contact.x = e.clientX;
    contact.y = e.clientY;
    eventStatus.textContent = `Pointer: move (id ${e.pointerId})`;
  }

  function handlePointerUp(e) {
    const contact = pointerContacts.get(e.pointerId);
    releaseContact(contact);
    pointerContacts.delete(e.pointerId);
    eventStatus.textContent = `Pointer: up (id ${e.pointerId})`;
  }

  function handleTouchStart(e) {
    ensureAudio();
    e.preventDefault();
    for (const touch of Array.from(e.changedTouches)) {
      const padIndex = getPadIndexFromClientXY(touch.clientX, touch.clientY);
      const voice = triggerPad(padIndex);
      touchContacts.set(touch.identifier, {
        padIndex,
        voice,
        x: touch.clientX,
        y: touch.clientY
      });
    }
    eventStatus.textContent = "Touch: start";
  }

  function handleTouchMove(e) {
    e.preventDefault();
    for (const touch of Array.from(e.changedTouches)) {
      const contact = touchContacts.get(touch.identifier);
      if (!contact) continue;
      const newPad = getPadIndexFromClientXY(touch.clientX, touch.clientY);
      if (newPad !== contact.padIndex) {
        releaseContact(contact);
        if (newPad >= 0) {
          contact.voice = triggerPad(newPad);
          contact.padIndex = newPad;
        }
      }
      contact.x = touch.clientX;
      contact.y = touch.clientY;
    }
    eventStatus.textContent = "Touch: move";
  }

  function handleTouchEnd(e) {
    e.preventDefault();
    for (const touch of Array.from(e.changedTouches)) {
      const contact = touchContacts.get(touch.identifier);
      releaseContact(contact);
      touchContacts.delete(touch.identifier);
    }
    eventStatus.textContent = "Touch: end";
  }

  function formatDiagnostics() {
    const pointerList = Array.from(pointerContacts.entries()).map(([id, c]) => {
      const padLabel = c.padIndex >= 0 ? c.padIndex + 1 : "-";
      return `P${id} @ ${Math.round(c.x)},${Math.round(c.y)} pad=${padLabel}`;
    });
    const touchList = Array.from(touchContacts.entries()).map(([id, c]) => {
      const padLabel = c.padIndex >= 0 ? c.padIndex + 1 : "-";
      return `T${id} @ ${Math.round(c.x)},${Math.round(c.y)} pad=${padLabel}`;
    });
    const activePads = Array.from(activePadCounts.keys()).sort((a, b) => a - b).map(i => i + 1);
    const totalContacts = pointerContacts.size + touchContacts.size;

    return [
      `Active contacts: ${totalContacts} (pointer ${pointerContacts.size}, touch ${touchContacts.size})`,
      "",
      "Pointer contacts:",
      pointerList.length ? pointerList.join("\n") : "(none)",
      "",
      "Touch contacts:",
      touchList.length ? touchList.join("\n") : "(none)",
      "",
      `Pressed pads: ${activePads.length ? activePads.join(", ") : "(none)"}`
    ].join("\n");
  }

  function tickDiagnostics() {
    diagOutput.textContent = formatDiagnostics();
  }

  function playTestNotes() {
    ensureAudio();
    const indices = [0, 5, 10, 15];
    indices.forEach((index, i) => {
      const voice = triggerPad(index);
      setTimeout(() => {
        if (voice) releaseVoice(voice, 0.1);
        decrementPad(index);
      }, 220 + i * 30);
    });
  }

  function setupPads() {
    const colors = ["var(--c1)", "var(--c2)", "var(--c3)", "var(--c4)"];
    for (let i = 0; i < 16; i++) {
      const pad = document.createElement("div");
      pad.className = "pad";
      pad.dataset.index = String(i);
      pad.tabIndex = 0;
      const number = document.createElement("div");
      number.className = "pad-number";
      number.textContent = String(i + 1);
      pad.appendChild(number);
      if (i < 4) {
        const label = document.createElement("div");
        label.className = "pad-label";
        label.textContent = chordMap[i];
        pad.appendChild(label);
      }
      pad.style.setProperty("--glow", colors[i % colors.length]);
      pads.push(pad);
      padSurface.appendChild(pad);
    }
  }

  unlockBtn.addEventListener("click", () => {
    ensureAudio();
    audioStatus.textContent = `Audio: ${audioCtx.state}`;
  });

  testBtn.addEventListener("click", playTestNotes);
  panicBtn.addEventListener("click", panic);

  padSurface.addEventListener("pointerdown", handlePointerDown);
  padSurface.addEventListener("pointermove", handlePointerMove);
  padSurface.addEventListener("pointerup", handlePointerUp);
  padSurface.addEventListener("pointercancel", handlePointerUp);

  padSurface.addEventListener("touchstart", handleTouchStart, { passive: false });
  padSurface.addEventListener("touchmove", handleTouchMove, { passive: false });
  padSurface.addEventListener("touchend", handleTouchEnd, { passive: false });
  padSurface.addEventListener("touchcancel", handleTouchEnd, { passive: false });

  window.addEventListener("blur", panic);
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) panic();
  });

  setupPads();
  tickDiagnostics();
  setInterval(tickDiagnostics, 33);
})();
</script>
</body>
</html>
