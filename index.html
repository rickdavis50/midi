<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pop Parts for Kids</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              display: ["Space Grotesk", "system-ui", "sans-serif"]
            },
            colors: {
              ink: "rgba(255,255,255,0.95)",
              muted: "rgba(255,255,255,0.65)"
            }
          }
        }
      };
    </script>
    <style>
      :root {
        --beat: 0.5s;
        --magic: 0.1;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #05060a;
        color: rgba(255, 255, 255, 0.95);
        font-family: "Space Grotesk", system-ui, sans-serif;
        overflow: hidden;
      }
      #three-canvas {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 0;
      }
      .app-shell {
        position: relative;
        z-index: 1;
      }
      .chord-btn {
        position: relative;
        border-radius: 22px;
        background:
          linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02)),
          linear-gradient(180deg, #121725, #0a0d17);
        border: 1px solid rgba(0, 0, 0, 0.6);
        box-shadow:
          inset 0 2px 3px rgba(255, 255, 255, 0.08),
          inset 0 -10px 18px rgba(0, 0, 0, 0.7),
          0 0 20px var(--glow),
          0 12px 20px rgba(0, 0, 0, 0.6);
        transition: transform 0.12s ease, box-shadow 0.12s ease;
        overflow: hidden;
      }
      .chord-btn::after {
        content: "";
        position: absolute;
        inset: -14px;
        border-radius: 28px;
        background:
          linear-gradient(180deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.2)),
          linear-gradient(180deg, var(--glow), rgba(0, 0, 0, 0.2));
        z-index: -1;
      }
      .chord-btn::before {
        content: "";
        position: absolute;
        inset: 10px;
        border-radius: 18px;
        background: linear-gradient(180deg, #0f131d, #0b0f18);
        box-shadow: inset 0 2px 3px rgba(255, 255, 255, 0.06);
      }
      .chord-btn.active {
        transform: translateY(3px) scale(0.99);
        box-shadow:
          inset 0 2px 3px rgba(255, 255, 255, 0.08),
          inset 0 -6px 12px rgba(0, 0, 0, 0.7),
          0 0 32px var(--glow),
          0 6px 16px rgba(0, 0, 0, 0.55);
        animation: glowBreath 2.2s ease-in-out infinite;
      }
      .pulse-ring {
        position: absolute;
        inset: 14px;
        border-radius: 18px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        opacity: 0;
        transform: scale(0.94);
      }
      .chord-btn.active .pulse-ring {
        opacity: 0.6;
        animation: pulseRing var(--beat) ease-in-out infinite;
      }
      .tempo-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #00e5ff;
        animation: tempoBounce var(--beat) linear infinite;
      }
      .groove-wobble {
        width: 18px;
        height: 6px;
        border-radius: 999px;
        background: #ff2dff;
        animation: grooveWobble 0.8s ease-in-out infinite;
      }
      .magic-shimmer {
        width: 24px;
        height: 10px;
        border-radius: 6px;
        background: linear-gradient(90deg, rgba(255, 210, 74, 0.3), rgba(255, 210, 74, 0.9));
        animation: shimmer 1.4s ease-in-out infinite;
        opacity: calc(0.3 + var(--magic));
      }
      .density-dots span {
        display: inline-block;
        width: 6px;
        height: 6px;
        margin-right: 2px;
        border-radius: 50%;
        background: #7cff4e;
        opacity: 0.2;
        transition: opacity 0.2s ease;
      }
      .density-dots[data-level="1"] span:nth-child(-n + 1),
      .density-dots[data-level="2"] span:nth-child(-n + 2),
      .density-dots[data-level="3"] span:nth-child(-n + 3),
      .density-dots[data-level="4"] span:nth-child(-n + 4) {
        opacity: 0.8;
      }
      @keyframes pulseRing {
        0% {
          transform: scale(0.94);
          opacity: 0.55;
        }
        50% {
          transform: scale(1.03);
          opacity: 0.2;
        }
        100% {
          transform: scale(0.94);
          opacity: 0.55;
        }
      }
      @keyframes glowBreath {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.75;
        }
      }
      @keyframes tempoBounce {
        0% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-6px);
        }
        100% {
          transform: translateY(0);
        }
      }
      @keyframes grooveWobble {
        0% {
          transform: rotate(-6deg) scaleX(0.9);
        }
        50% {
          transform: rotate(6deg) scaleX(1.1);
        }
        100% {
          transform: rotate(-6deg) scaleX(0.9);
        }
      }
      @keyframes shimmer {
        0% {
          transform: translateX(-2px);
          opacity: 0.4;
        }
        50% {
          transform: translateX(2px);
          opacity: 0.9;
        }
        100% {
          transform: translateX(-2px);
          opacity: 0.4;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .chord-btn.active,
        .chord-btn.active .pulse-ring,
        .tempo-dot,
        .groove-wobble,
        .magic-shimmer {
          animation: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="three-canvas"></div>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      const CHORDS = [
        { name: "C", label: "Happy", glow: "#ff1b7a", notes: [60, 64, 67, 72] },
        { name: "G", label: "Bright", glow: "#2f3aa8", notes: [55, 59, 62, 67] },
        { name: "Am", label: "Dreamy", glow: "#f2ff5a", notes: [57, 60, 64, 69] },
        { name: "F", label: "Warm", glow: "#7fb4ff", notes: [53, 57, 60, 65] },
        { name: "Dm", label: "Soft", glow: "#ff7ae2", notes: [50, 53, 57, 62] },
        { name: "Em", label: "Cool", glow: "#54f3ff", notes: [52, 55, 59, 64] },
        { name: "G/B", label: "Lift", glow: "#ffa642", notes: [59, 62, 67, 71] },
        { name: "C/E", label: "Glow", glow: "#7cff4e", notes: [52, 55, 60, 64] }
      ];

      function App() {
        const [bpm, setBpm] = useState(120);
        const [groove, setGroove] = useState(60);
        const [density, setDensity] = useState(25);
        const [magic, setMagic] = useState(10);
        const [activeChord, setActiveChord] = useState(null);
        const appRef = useRef(null);
        const threeRef = useRef(null);
        const audioRef = useRef({
          audioCtx: null,
          masterGain: null,
          masterBus: null,
          saturator: null,
          compressor: null,
          delaySend: null,
          delayNode: null,
          delayFeedback: null,
          delayFilter: null,
          noiseBuffer: null,
          currentChordVoice: null,
          currentChordName: null,
          beatRunning: false,
          schedulerTimer: null,
          nextStepTime: 0,
          stepIndex: 0
        });

        const chordMap = useMemo(() => {
          const map = {};
          CHORDS.forEach((chord) => {
            map[chord.name] = chord.notes;
          });
          return map;
        }, []);

        useEffect(() => {
          document.documentElement.style.setProperty("--beat", `${60 / bpm}s`);
        }, [bpm]);

        useEffect(() => {
          document.documentElement.style.setProperty("--magic", (magic / 100).toFixed(2));
        }, [magic]);

        useEffect(() => {
          const container = document.getElementById("three-canvas");
          const width = window.innerWidth;
          const height = window.innerHeight;

          const scene = new THREE.Scene();
          const camera = new THREE.OrthographicCamera(0, width, height, 0, -1000, 1000);
          camera.position.z = 10;

          const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          renderer.setPixelRatio(window.devicePixelRatio || 1);
          renderer.setSize(width, height);
          container.appendChild(renderer.domElement);

          const maxParticles = 1400;
          const positions = new Float32Array(maxParticles * 3);
          const colors = new Float32Array(maxParticles * 3);
          const baseColors = new Float32Array(maxParticles * 3);
          const velocities = new Float32Array(maxParticles * 2);
          const ages = new Float32Array(maxParticles);
          const lifetimes = new Float32Array(maxParticles);
          const activeSet = new Set();
          const freeList = Array.from({ length: maxParticles }, (_, i) => i);

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
          const material = new THREE.PointsMaterial({
            size: 7,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
          });
          const points = new THREE.Points(geometry, material);
          scene.add(points);

          const color = new THREE.Color();
          let lastTime = performance.now();
          let raf = null;

          function animate(now) {
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            activeSet.forEach((index) => {
              ages[index] += delta;
              if (ages[index] >= lifetimes[index]) {
                positions[index * 3 + 0] = -9999;
                positions[index * 3 + 1] = -9999;
                positions[index * 3 + 2] = 0;
                activeSet.delete(index);
                freeList.push(index);
                return;
              }
              const t = ages[index] / lifetimes[index];
              positions[index * 3 + 0] += velocities[index * 2 + 0] * delta;
              positions[index * 3 + 1] += velocities[index * 2 + 1] * delta + t * t * 40;
              positions[index * 3 + 2] = 0;
              const fade = Math.max(0, 1 - t);
              colors[index * 3 + 0] = baseColors[index * 3 + 0] * fade;
              colors[index * 3 + 1] = baseColors[index * 3 + 1] * fade;
              colors[index * 3 + 2] = baseColors[index * 3 + 2] * fade;
            });
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
            raf = requestAnimationFrame(animate);
          }

          function spawnParticles(x, y, hex) {
            color.set(hex);
            const count = 110;
            for (let i = 0; i < count; i++) {
              const index = freeList.pop();
              if (index === undefined) break;
              activeSet.add(index);
              const angle = Math.random() * Math.PI * 2;
              const speed = 120 + Math.random() * 520;
              positions[index * 3 + 0] = i % 4 === 0 ? Math.random() * width : x;
              positions[index * 3 + 1] = i % 4 === 0 ? Math.random() * height : y;
              positions[index * 3 + 2] = 0;
              velocities[index * 2 + 0] = Math.cos(angle) * speed;
              velocities[index * 2 + 1] = Math.sin(angle) * speed;
              ages[index] = 0;
              lifetimes[index] = 0.9 + Math.random() * 1.2;
              baseColors[index * 3 + 0] = color.r;
              baseColors[index * 3 + 1] = color.g;
              baseColors[index * 3 + 2] = color.b;
              colors[index * 3 + 0] = color.r;
              colors[index * 3 + 1] = color.g;
              colors[index * 3 + 2] = color.b;
            }
          }

          function handleResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.right = w;
            camera.bottom = h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
          }

          raf = requestAnimationFrame(animate);
          window.addEventListener("resize", handleResize);

          threeRef.current = { spawnParticles };

          return () => {
            window.removeEventListener("resize", handleResize);
            if (raf) cancelAnimationFrame(raf);
            renderer.dispose();
            geometry.dispose();
            material.dispose();
            container.removeChild(renderer.domElement);
          };
        }, []);

        function ensureAudio() {
          const store = audioRef.current;
          if (!store.audioCtx) {
            store.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            setupAudioChain(store);
          }
          if (store.audioCtx.state === "suspended") {
            store.audioCtx.resume();
          }
        }

        function setupAudioChain(store) {
          const { audioCtx } = store;
          store.masterBus = audioCtx.createGain();
          store.masterBus.gain.value = 1;

          store.masterGain = audioCtx.createGain();
          store.masterGain.gain.value = 0.65;

          store.saturator = audioCtx.createWaveShaper();
          store.saturator.curve = makeSaturationCurve(0.2);
          store.saturator.oversample = "2x";

          store.compressor = audioCtx.createDynamicsCompressor();
          store.compressor.threshold.value = -18;
          store.compressor.knee.value = 20;
          store.compressor.ratio.value = 2.2;
          store.compressor.attack.value = 0.008;
          store.compressor.release.value = 0.12;

          store.delaySend = audioCtx.createGain();
          store.delaySend.gain.value = 0.08;
          store.delayNode = audioCtx.createDelay(0.6);
          store.delayNode.delayTime.value = 0.25;
          store.delayFeedback = audioCtx.createGain();
          store.delayFeedback.gain.value = 0.25;
          store.delayFilter = audioCtx.createBiquadFilter();
          store.delayFilter.type = "lowpass";
          store.delayFilter.frequency.value = 2600;

          store.masterBus.connect(store.saturator);
          store.saturator.connect(store.compressor);
          store.compressor.connect(store.masterGain);
          store.masterGain.connect(audioCtx.destination);

          store.masterBus.connect(store.delaySend);
          store.delaySend.connect(store.delayNode);
          store.delayNode.connect(store.delayFilter);
          store.delayFilter.connect(store.compressor);
          store.delayNode.connect(store.delayFeedback);
          store.delayFeedback.connect(store.delayNode);

          store.noiseBuffer = createNoiseBuffer(audioCtx);
        }

        function makeSaturationCurve(amount) {
          const samples = 44100;
          const curve = new Float32Array(samples);
          const k = amount * 40;
          for (let i = 0; i < samples; i++) {
            const x = (i * 2) / samples - 1;
            curve[i] = ((1 + k) * x) / (1 + k * Math.abs(x));
          }
          return curve;
        }

        function createNoiseBuffer(audioCtx) {
          const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1, audioCtx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          return buffer;
        }

        function midiToFreq(midi) {
          return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function updateMagic(nextMagic) {
          const store = audioRef.current;
          const drive = 0.15 + nextMagic * 0.5;
          if (store.saturator) store.saturator.curve = makeSaturationCurve(drive);
          if (store.delaySend) store.delaySend.gain.value = 0.05 + nextMagic * 0.08;
        }

        function createNoiseBurst(time, duration, gainValue, freq) {
          const store = audioRef.current;
          const { audioCtx, noiseBuffer, masterBus } = store;
          const noise = audioCtx.createBufferSource();
          noise.buffer = noiseBuffer;
          const filter = audioCtx.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.value = freq;
          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(gainValue, time);
          gain.gain.exponentialRampToValueAtTime(0.0001, time + duration);
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(masterBus);
          noise.start(time);
          noise.stop(time + duration + 0.02);
        }

        function createChordVoice(chordName) {
          const store = audioRef.current;
          const now = store.audioCtx.currentTime;
          const notes = chordMap[chordName] || chordMap.C;
          const voiceGain = store.audioCtx.createGain();
          voiceGain.gain.setValueAtTime(0.0001, now);
          voiceGain.gain.linearRampToValueAtTime(0.5, now + 0.04);

          const filter = store.audioCtx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.setValueAtTime(1400, now);
          filter.frequency.linearRampToValueAtTime(2200, now + 1.5);

          const lfo = store.audioCtx.createOscillator();
          const lfoGain = store.audioCtx.createGain();
          lfo.frequency.value = 0.35 + (magic / 100) * 0.6;
          lfoGain.gain.value = 60 + (magic / 100) * 120;
          lfo.connect(lfoGain);
          lfoGain.connect(filter.frequency);

          const shimmerGain = store.audioCtx.createGain();
          shimmerGain.gain.setValueAtTime(0.0001, now + 1.5);
          shimmerGain.gain.linearRampToValueAtTime(0.12 + (magic / 100) * 0.18, now + 3);

          const nodes = notes.map((midi, i) => {
            const osc = store.audioCtx.createOscillator();
            const osc2 = store.audioCtx.createOscillator();
            const pan = store.audioCtx.createStereoPanner();
            const detune = (i % 2 === 0 ? -6 : 6) * (1 + (magic / 100) * 0.5);
            osc.type = "triangle";
            osc.frequency.value = midiToFreq(midi);
            osc.detune.value = detune;
            osc2.type = "sawtooth";
            osc2.frequency.value = midiToFreq(midi);
            osc2.detune.value = detune * 0.4;
            pan.pan.value = (i - 1.5) * 0.2;
            osc.connect(pan);
            osc2.connect(pan);
            pan.connect(filter);
            osc.start(now + i * 0.012);
            osc2.start(now + i * 0.012);
            return { osc, osc2 };
          });

          const shimmerOsc = store.audioCtx.createOscillator();
          shimmerOsc.type = "triangle";
          shimmerOsc.frequency.value = midiToFreq(notes[0] + 12);
          shimmerOsc.connect(shimmerGain);
          shimmerGain.connect(filter);
          shimmerOsc.start(now + 1.5);

          filter.connect(voiceGain);
          voiceGain.connect(store.masterBus);

          createNoiseBurst(now, 0.06, 0.2, 2200);
          lfo.start(now + 1.5);

          return {
            stop(release = 0.16) {
              const t = store.audioCtx.currentTime;
              voiceGain.gain.cancelScheduledValues(t);
              voiceGain.gain.setValueAtTime(Math.max(voiceGain.gain.value, 0.0001), t);
              voiceGain.gain.exponentialRampToValueAtTime(0.0001, t + release);
              nodes.forEach(({ osc, osc2 }) => {
                osc.stop(t + release + 0.05);
                osc2.stop(t + release + 0.05);
              });
              shimmerOsc.stop(t + release + 0.05);
              lfo.stop(t + release + 0.05);
            }
          };
        }

        function playKick(time) {
          const store = audioRef.current;
          const osc = store.audioCtx.createOscillator();
          const gain = store.audioCtx.createGain();
          osc.type = "sine";
          osc.frequency.setValueAtTime(120, time);
          osc.frequency.exponentialRampToValueAtTime(40, time + 0.12);
          gain.gain.setValueAtTime(0.9, time);
          gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.16);
          osc.connect(gain);
          gain.connect(store.masterBus);
          osc.start(time);
          osc.stop(time + 0.18);
          createNoiseBurst(time, 0.02, 0.12, 1800);
        }

        function playSnare(time) {
          const store = audioRef.current;
          const osc = store.audioCtx.createOscillator();
          const gain = store.audioCtx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(190, time);
          gain.gain.setValueAtTime(0.2, time);
          gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
          osc.connect(gain);
          gain.connect(store.masterBus);
          osc.start(time);
          osc.stop(time + 0.2);
          [0, 0.015, 0.03].forEach((offset, i) => {
            createNoiseBurst(time + offset, 0.12, 0.22 - i * 0.04, 1800);
          });
        }

        function playHat(time, length) {
          const store = audioRef.current;
          const noise = store.audioCtx.createBufferSource();
          noise.buffer = store.noiseBuffer;
          const filter = store.audioCtx.createBiquadFilter();
          filter.type = "highpass";
          filter.frequency.value = 5200;
          const gain = store.audioCtx.createGain();
          gain.gain.setValueAtTime(0.08 + (density / 100) * 0.08, time);
          gain.gain.exponentialRampToValueAtTime(0.0001, time + length);
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(store.masterBus);
          noise.start(time);
          noise.stop(time + length + 0.02);
        }

        function scheduleBeat() {
          const store = audioRef.current;
          const scheduleAhead = 0.15;
          const stepDur = (60 / bpm) / 4;
          const swingAmount = 0.5 + (groove / 100) * 0.12;

          while (store.nextStepTime < store.audioCtx.currentTime + scheduleAhead) {
            const step = store.stepIndex % 16;
            const beat = step % 4;
            const time = store.nextStepTime;

            const kickOn1 = density / 100 > 0.25;
            if (step === 0 || (kickOn1 && step === 8)) {
              playKick(time);
            }
            if (step === 4 || step === 12) {
              playSnare(time);
            }
            const swingOffset = (step % 2 === 1) ? (swingAmount - 0.5) * stepDur : 0;
            if (step % 2 === 0 || density / 100 > 0.35) {
              const hatLen = density / 100 > 0.6 ? 0.14 : 0.08;
              playHat(time + swingOffset, hatLen);
            }
            if (density / 100 > 0.7 && beat === 3) {
              playHat(time + swingOffset + stepDur * 0.5, 0.05);
            }
            if (density / 100 > 0.8 && step === 14) {
              playSnare(time + 0.01);
            }

            store.nextStepTime += stepDur;
            store.stepIndex += 1;
          }

          store.schedulerTimer = setTimeout(scheduleBeat, 25);
        }

        function startBeat() {
          const store = audioRef.current;
          if (store.beatRunning) return;
          store.beatRunning = true;
          store.nextStepTime = store.audioCtx.currentTime + 0.05;
          store.stepIndex = 0;
          scheduleBeat();
        }

        function stopBeat() {
          const store = audioRef.current;
          store.beatRunning = false;
          if (store.schedulerTimer) clearTimeout(store.schedulerTimer);
          store.schedulerTimer = null;
        }

        function stopAll() {
          stopBeat();
          const store = audioRef.current;
          if (store.currentChordVoice) {
            store.currentChordVoice.stop(0.08);
            store.currentChordVoice = null;
          }
          store.currentChordName = null;
          setActiveChord(null);
        }

        function handleChordDown(chord, event) {
          ensureAudio();
          event.currentTarget.setPointerCapture(event.pointerId);
          if (threeRef.current) {
            threeRef.current.spawnParticles(event.clientX, event.clientY, chord.glow);
          }
          const store = audioRef.current;
          if (store.currentChordName !== chord.name) {
            if (store.currentChordVoice) {
              store.currentChordVoice.stop(0.14);
            }
            store.currentChordVoice = createChordVoice(chord.name);
            store.currentChordName = chord.name;
            setActiveChord(chord.name);
          }
          startBeat();
        }

        function handleChordUp() {
          const store = audioRef.current;
          if (store.currentChordVoice) store.currentChordVoice.stop(0.16);
          store.currentChordVoice = null;
          store.currentChordName = null;
          setActiveChord(null);
        }

        function handleUnlock() {
          ensureAudio();
          startBeat();
        }

        function handlePanic() {
          stopAll();
        }

        useEffect(() => {
          updateMagic(magic / 100);
        }, [magic]);

        useEffect(() => {
          const handleBlur = () => stopAll();
          const handleVisibility = () => {
            if (document.hidden) stopAll();
          };
          window.addEventListener("blur", handleBlur);
          document.addEventListener("visibilitychange", handleVisibility);
          return () => {
            window.removeEventListener("blur", handleBlur);
            document.removeEventListener("visibilitychange", handleVisibility);
          };
        }, []);

        const grooveLabel = groove < 40 ? "Straight" : groove < 70 ? "Bouncy" : "Wiggly";
        const densityLabel = density < 40 ? "Simple" : density < 70 ? "Fun" : "Busy";
        const magicLabel = magic < 30 ? "Clean" : magic < 70 ? "Sparkly" : "Alien";
        const densityLevel = density < 25 ? "1" : density < 50 ? "2" : density < 75 ? "3" : "4";

        return (
          <div
            ref={appRef}
            className="app-shell min-h-screen w-full bg-[radial-gradient(circle_at_top,_rgba(54,64,120,0.55),_rgba(5,6,10,0.95)_55%),_linear-gradient(120deg,_rgba(8,15,28,0.9),_rgba(2,2,6,1))] text-ink px-5 py-6"
          >
            <div className="mx-auto flex max-w-5xl flex-wrap items-center justify-between gap-4">
              <div className="text-lg font-semibold uppercase tracking-[0.2em]">Pop Parts for Kids</div>
              <div className="flex flex-wrap gap-3">
                <button
                  onClick={handleUnlock}
                  className="rounded-full border border-white/20 bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.2em] text-ink shadow-[0_0_16px_rgba(0,229,255,0.3)] transition hover:border-cyan-300 hover:shadow-[0_0_18px_rgba(0,229,255,0.45)]"
                >
                  Unlock Audio
                </button>
                <button
                  onClick={handlePanic}
                  className="rounded-full border border-pink-400/40 bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.2em] text-ink shadow-[0_0_12px_rgba(255,45,255,0.35)] transition hover:border-pink-300"
                >
                  Panic
                </button>
              </div>
            </div>

            <div className="mx-auto mt-6 grid max-w-5xl items-center gap-6 lg:grid-cols-[minmax(280px,1fr)_minmax(260px,320px)]">
              <div className="grid grid-cols-2 gap-3 sm:grid-cols-4">
                {CHORDS.map((chord) => (
                  <button
                    key={chord.name}
                    className={`chord-btn flex h-[120px] flex-col items-center justify-center gap-2 text-2xl font-bold uppercase tracking-[0.08em] text-ink ${
                      activeChord === chord.name ? "active" : ""
                    }`}
                    style={{ "--glow": chord.glow }}
                    onPointerDown={(event) => handleChordDown(chord, event)}
                    onPointerUp={handleChordUp}
                    onPointerCancel={handleChordUp}
                    onPointerLeave={handleChordUp}
                  >
                    <span className="relative z-10">{chord.name}</span>
                    <span className="relative z-10 text-xs uppercase tracking-[0.2em] text-muted">
                      {chord.label}
                    </span>
                    <span className="pulse-ring"></span>
                  </button>
                ))}
              </div>

              <div className="rounded-2xl border border-white/10 bg-white/5 p-5 backdrop-blur">
                <div className="text-xs uppercase tracking-[0.2em] text-muted">Hold a chord to hear it evolve.</div>

                <div className="mt-5 space-y-4">
                  <div className="grid gap-2">
                    <div className="flex items-center justify-between text-xs uppercase tracking-[0.2em]">
                      <span>Tempo</span>
                      <span className="text-sm tabular-nums">{bpm}</span>
                    </div>
                    <input
                      type="range"
                      min="80"
                      max="160"
                      value={bpm}
                      onChange={(event) => setBpm(Number(event.target.value))}
                      className="w-full accent-cyan-300"
                    />
                    <div className="flex items-center gap-2 text-xs text-muted">
                      <span className="tempo-dot"></span>
                      <span>Speed</span>
                    </div>
                  </div>

                  <div className="grid gap-2">
                    <div className="flex items-center justify-between text-xs uppercase tracking-[0.2em]">
                      <span>Groove</span>
                      <span className="text-sm tabular-nums">{grooveLabel}</span>
                    </div>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={groove}
                      onChange={(event) => setGroove(Number(event.target.value))}
                      className="w-full accent-fuchsia-400"
                    />
                    <div className="flex items-center gap-2 text-xs text-muted">
                      <span className="groove-wobble"></span>
                      <span>Feel</span>
                    </div>
                  </div>

                  <div className="grid gap-2">
                    <div className="flex items-center justify-between text-xs uppercase tracking-[0.2em]">
                      <span>Density</span>
                      <span className="text-sm tabular-nums">{densityLabel}</span>
                    </div>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={density}
                      onChange={(event) => setDensity(Number(event.target.value))}
                      className="w-full accent-lime-300"
                    />
                    <div className="density-dots text-xs text-muted" data-level={densityLevel}>
                      <span></span>
                      <span></span>
                      <span></span>
                      <span></span>
                    </div>
                  </div>

                  <div className="grid gap-2">
                    <div className="flex items-center justify-between text-xs uppercase tracking-[0.2em]">
                      <span>Magic</span>
                      <span className="text-sm tabular-nums">{magicLabel}</span>
                    </div>
                    <input
                      type="range"
                      min="0"
                      max="100"
                      value={magic}
                      onChange={(event) => setMagic(Number(event.target.value))}
                      className="w-full accent-amber-300"
                    />
                    <div className="flex items-center gap-2 text-xs text-muted">
                      <span className="magic-shimmer"></span>
                      <span>Sparkle</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
