<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MIDI Pads Pointer Lock MVP</title>
<style>
  :root {
    --bg: #0b0c10;
    --panel: rgba(15, 19, 27, 0.9);
    --pad: #1f2430;
    --pad-active: #3fe0a6;
    --text: #e6e6e6;
    --muted: #97a1b3;
    --accent: #ffb347;
    --border: #2c3343;
    --warning: #ff6b3d;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: "Space Grotesk", "Helvetica Neue", Arial, sans-serif;
    overflow: hidden;
  }
  .pad-surface {
    position: fixed;
    inset: 0;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 10px;
    padding: 12px;
    background: linear-gradient(160deg, #0a0c12, #0f131b 60%, #0b0c10);
    touch-action: none;
    cursor: crosshair;
  }
  .pad {
    background: var(--pad);
    border: 1px solid var(--border);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: var(--muted);
    user-select: none;
  }
  .pad.active {
    background: var(--pad-active);
    color: #0b0c10;
    border-color: #7df4c9;
    box-shadow: 0 0 18px rgba(63, 224, 166, 0.6);
  }
  .overlay {
    position: fixed;
    top: 12px;
    left: 12px;
    right: 12px;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: stretch;
    justify-content: space-between;
    pointer-events: none;
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    pointer-events: auto;
    backdrop-filter: blur(6px);
  }
  .warning {
    color: var(--warning);
    font-size: 13px;
    font-weight: 600;
  }
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  button {
    background: #121722;
    color: var(--text);
    border: 1px solid var(--border);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
  }
  button:hover { border-color: var(--accent); }
  .diagnostics {
    width: min(360px, 92vw);
    font-size: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .diagnostics pre {
    margin: 0;
    background: #0f131b;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    color: var(--text);
    max-height: 200px;
    overflow: auto;
  }
</style>
</head>
<body>
  <div id="padSurface" class="pad-surface" aria-label="Pad grid"></div>

  <div class="overlay">
    <div class="panel">
      <div class="warning">Browser limitation: absolute trackpad touch zones require native app.</div>
      <div class="controls" style="margin-top:8px;">
        <button id="unlockBtn">Unlock Audio</button>
        <button id="testBtn">Test: play 4 notes</button>
        <button id="panicBtn">Panic / Stop</button>
      </div>
    </div>
    <div class="panel diagnostics">
      <div id="audioStatus">Audio: locked</div>
      <div id="lockStatus">Pointer lock: not engaged</div>
      <pre id="diagOutput"></pre>
    </div>
  </div>

<script>
(() => {
  const padSurface = document.getElementById("padSurface");
  const diagOutput = document.getElementById("diagOutput");
  const audioStatus = document.getElementById("audioStatus");
  const lockStatus = document.getElementById("lockStatus");
  const unlockBtn = document.getElementById("unlockBtn");
  const testBtn = document.getElementById("testBtn");
  const panicBtn = document.getElementById("panicBtn");

  const pads = [];
  const activePadCounts = new Map();
  const activeVoices = new Set();
  const latchedContacts = new Map();

  let audioCtx = null;
  let vx = 0.5;
  let vy = 0.5;
  let pointerLocked = false;

  const frequencies = [
    196, 220, 247, 262,
    294, 330, 349, 392,
    440, 494, 523, 587,
    659, 698, 784, 880
  ];

  function ensureAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }
    audioStatus.textContent = `Audio: ${audioCtx.state}`;
  }

  function createVoice(frequency) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.value = frequency;
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const t = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.linearRampToValueAtTime(0.9, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.25, t + 0.12);

    osc.start(t);

    const voice = {
      osc,
      gain,
      stop(release = 0.08) {
        const now = audioCtx.currentTime;
        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(Math.max(gain.gain.value, 0.0001), now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + release);
        osc.stop(now + release + 0.02);
      }
    };
    activeVoices.add(voice);
    osc.onended = () => activeVoices.delete(voice);
    return voice;
  }

  function incrementPad(index) {
    const count = (activePadCounts.get(index) || 0) + 1;
    activePadCounts.set(index, count);
    pads[index].classList.toggle("active", count > 0);
  }

  function decrementPad(index) {
    if (index == null || index < 0) return;
    const count = (activePadCounts.get(index) || 0) - 1;
    if (count <= 0) {
      activePadCounts.delete(index);
      pads[index].classList.remove("active");
    } else {
      activePadCounts.set(index, count);
    }
  }

  function triggerPad(index) {
    if (index == null || index < 0) return null;
    const voice = createVoice(frequencies[index % frequencies.length]);
    incrementPad(index);
    return voice;
  }

  function releaseVoice(voice, index) {
    if (voice) voice.stop();
    if (index != null && index >= 0) decrementPad(index);
  }

  function stopAllVoices() {
    for (const voice of Array.from(activeVoices)) {
      voice.stop(0.02);
    }
    activeVoices.clear();
  }

  function panic() {
    stopAllVoices();
    latchedContacts.clear();
    activePadCounts.clear();
    pads.forEach(p => p.classList.remove("active"));
  }

  function getPadIndexFromNormalized(x, y) {
    const col = Math.min(3, Math.max(0, Math.floor(x * 4)));
    const row = Math.min(3, Math.max(0, Math.floor(y * 4)));
    return row * 4 + col;
  }

  function getNormalizedFromClientXY(x, y) {
    const rect = padSurface.getBoundingClientRect();
    const nx = (x - rect.left) / rect.width;
    const ny = (y - rect.top) / rect.height;
    return {
      nx: Math.min(1, Math.max(0, nx)),
      ny: Math.min(1, Math.max(0, ny))
    };
  }

  function requestLock() {
    if (!pointerLocked) {
      padSurface.requestPointerLock();
    }
  }

  function updateVirtualCursor(dx, dy) {
    const rect = padSurface.getBoundingClientRect();
    const scaleX = 1 / Math.max(1, rect.width);
    const scaleY = 1 / Math.max(1, rect.height);
    vx = Math.min(1, Math.max(0, vx + dx * scaleX));
    vy = Math.min(1, Math.max(0, vy + dy * scaleY));
  }

  function triggerAtVirtualPosition(modified) {
    const padIndex = getPadIndexFromNormalized(vx, vy);
    if (!modified) {
      for (const entry of Array.from(latchedContacts.values())) {
        releaseVoice(entry.voice, entry.padIndex);
      }
      latchedContacts.clear();
    }
    const voice = triggerPad(padIndex);
    latchedContacts.set(Symbol("contact"), { padIndex, voice });
  }

  function handleMouseDown(e) {
    ensureAudio();
    const isModified = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey;
    if (!pointerLocked) {
      const { nx, ny } = getNormalizedFromClientXY(e.clientX, e.clientY);
      vx = nx;
      vy = ny;
      triggerAtVirtualPosition(isModified);
      requestLock();
      return;
    }
    triggerAtVirtualPosition(isModified);
  }

  function handleMouseMove(e) {
    if (!pointerLocked) return;
    updateVirtualCursor(e.movementX, e.movementY);
  }

  function handleMouseUp(e) {
    if (!pointerLocked) return;
    const isModified = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey;
    if (isModified) return;
    for (const entry of Array.from(latchedContacts.values())) {
      releaseVoice(entry.voice, entry.padIndex);
    }
    latchedContacts.clear();
  }

  function formatDiagnostics() {
    const padIndex = getPadIndexFromNormalized(vx, vy);
    const activePads = Array.from(activePadCounts.keys()).sort((a, b) => a - b).map(i => i + 1);
    return [
      `Virtual cursor: ${vx.toFixed(3)}, ${vy.toFixed(3)} (pad ${padIndex + 1})`,
      `Latched voices: ${latchedContacts.size}`,
      `Pressed pads: ${activePads.length ? activePads.join(", ") : "(none)"}`
    ].join("\n");
  }

  function tickDiagnostics() {
    diagOutput.textContent = formatDiagnostics();
  }

  function playTestNotes() {
    ensureAudio();
    const indices = [0, 5, 10, 15];
    indices.forEach((index, i) => {
      const voice = triggerPad(index);
      setTimeout(() => {
        releaseVoice(voice, index);
      }, 220 + i * 30);
    });
  }

  function setupPads() {
    for (let i = 0; i < 16; i++) {
      const pad = document.createElement("div");
      pad.className = "pad";
      pad.textContent = String(i + 1);
      pads.push(pad);
      padSurface.appendChild(pad);
    }
  }

  unlockBtn.addEventListener("click", () => {
    ensureAudio();
    audioStatus.textContent = `Audio: ${audioCtx.state}`;
  });

  testBtn.addEventListener("click", playTestNotes);
  panicBtn.addEventListener("click", panic);

  padSurface.addEventListener("mousedown", handleMouseDown);
  padSurface.addEventListener("mousemove", handleMouseMove);
  padSurface.addEventListener("mouseup", handleMouseUp);

  document.addEventListener("pointerlockchange", () => {
    pointerLocked = document.pointerLockElement === padSurface;
    lockStatus.textContent = pointerLocked ? "Pointer lock: engaged" : "Pointer lock: not engaged";
  });

  window.addEventListener("blur", () => {
    panic();
    if (pointerLocked) document.exitPointerLock();
  });
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      panic();
      if (pointerLocked) document.exitPointerLock();
    }
  });

  setupPads();
  tickDiagnostics();
  setInterval(tickDiagnostics, 33);
})();
</script>
</body>
</html>
